
from geopandas import read_file, GeoSeries, gdf
from math import hypot, sin, cos, radians
from math import sqrt
from numpy.random import uniform
from pathlib import Path
from pyproj import CRS
from rtree.index import Index
from shapely.geometry import Point, Polygon, MultiPoint

def distance(x1, y1, x2, y2):
	"""
	* Use Pythagoras' theorem to measure distance. This is acceptable in this 
      case because:
	*	 - the CRS of the data is a local projection
	*	 - the distances are short
	*    - computational efficiency is important (as we are making many
            measurements)
	"""
	return sqrt((x1 - x2)**2 + (y1 - y2)**2)

def offset(x,y, distance, direction):
    """
    * Offset a location by a given distance and direction
    """
    x2 = x + cos(radians(direction)) * distance
    y2 = y + sin(radians(direction)) * distance
    return (x2, y2)

def get_rand_nums(x,y):
        rand_dir = uniform(0,360)
        rand_dist = uniform(0,10000)
        return(Point(offset(x , y, rand_dir, rand_dist)))
    


BNG = CRS. from_epsg (27700)

#read in the greater manchester district polygons in the correct crs
gm_districts = read_file("../assessment2/data/gm-districts.shp").to_crs(BNG)
print(gm_districts)

pointData = read_file("../assessment2/data/level3-tweets-subset.shp").to_crs(BNG)
print(pointData)

geometries = gm_districts['geometry']
print(geometries)
bound = gm_districts.bounds

idx = Index()
for id, point in pointData.iterrows():
    idx.insert(id, point.geometry.bounds)

print(idx)
print(id)
print(point.geometry.bounds)

for i in range(len(geometries)):
    b = geometries[i].bounds
    c = geometries[i].centroid
   
    print(b)
    print(c)
    
    #issues with the bounding box: a bounding box around a polygon will intersect with other polygons,
    #so points within that bounding box are not necessarily within the districts' limits     
    possible_matches_index= list(idx.intersection(b))
        
    print(possible_matches_index)
    
    # use those indexes to extract the possible matches from the GeoDataFrame
    possible_matches = pointData.iloc[possible_matches_index]
    
    print(possible_matches)
    
    # how many rows are left now? 
    print(f"Filtered points: {len(possible_matches.index)}")               

    #loop through the possible_match dataframe to get index of each row (from 0 onwards) and lat,lng columns    
    for i, row in enumerate(gdf.to_dict(possible_matches="lat,lng")):
        print(['lat'])
        pts = get_rand_nums(x,y)
        
        random_points = []
        while len(random_points) < 12:
            if pts.within(b) == True:
                random_points.append(x,y)
            else:
                continue
